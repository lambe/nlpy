      subroutine dspcg(n,x,xl,xu,aprod,g,
     +                 delta,rtol,s,itermax,iters,info,
     +                 indfree,gfree,w,wa,wx,wy,iwa)
      integer n, itermax, iters, info
      integer indfree(n), iwa(3*n)
      double precision rtol
      double precision x(n), xl(n), xu(n), g(n), delta, s(n)
      double precision gfree(n), w(n)
      double precision wa(5*n)
      double precision wx(n), wy(n)
      external aprod
c     *********
c     
c     Subroutine dspcg
c
c     This subroutine generates a sequence of approximate minimizers
c     for the subproblem
c
c           min { q(x) : xl <= x <= xu }.
c
c     The quadratic is defined by
c
c           q(x[0]+s) = 0.5*s'*A*s + g'*s,
c
c     where x[0] is a base point provided by the user, A is a symmetric 
c     matrix in compressed column storage, and g is a vector.
c
c     At each stage we have an approximate minimizer x[k], and generate
c     a direction p[k] by using a preconditioned conjugate gradient 
c     method on the subproblem
c
c           min { q(x[k]+p) : || L'*p || <= delta, s(fixed) = 0 },
c
c     where fixed is the set of variables fixed at x[k], delta is the 
c     trust region bound, and L is an incomplete Cholesky factorization
c     of the submatrix
c
c           B = A(free:free),
c
c     where free is the set of free variables at x[k]. Given p[k],
c     the next minimizer x[k+1] is generated by a projected search.
c
c     The starting point for this subroutine is x[1] = x[0] + s, where 
c     x[0] is a base point and s is the Cauchy step.
c
c     The subroutine converges when the step s satisfies
c
c           || (g + A*s)[free] || <= rtol*|| g[free] ||
c
c     In this case the final x is an approximate minimizer in the 
c     face defined by the free variables.
c
c     The subroutine terminates when the trust region bound does 
c     not allow further progress, that is, || L'*p[k] || = delta.
c     In this case the final x satisfies q(x) < q(x[k]).
c
c     The subroutine statement is
c
c       subroutine dspcg(n,x,xl,xu,a,adiag,acol_ptr,arow_ind,g,delta,
c                        rtol,s,nv,itermax,iters,info,
c                        b,bdiag,bcol_ptr,brow_ind,
c                        l,ldiag,lcol_ptr,lrow_ind,
c                        indfree,gfree,w,wa,iwa)
c
c     where
c
c       n is an integer variable.
c         On entry n is the number of variables.
c         On exit n is unchanged.
c
c       x is a double precision array of dimension n.
c         On entry x specifies the vector x.
c         On exit x is the final minimizer.
c
c       xl is a double precision array of dimension n.
c         On entry xl is the vector of lower bounds.
c         On exit xl is unchanged.
c
c       xu is a double precision array of dimension n.
c         On entry xu is the vector of upper bounds.
c         On exit xu is unchanged.
c
c       a is a double precision array of dimension nnz.
c         On entry a must contain the strict lower triangular part
c            of A in compressed column storage.
c         On exit a is unchanged.
c
c       adiag is a double precision array of dimension n.
c         On entry adiag must contain the diagonal elements of A.
c         On exit adiag is unchanged.
c
c       acol_ptr is an integer array of dimension n + 1.
c         On entry acol_ptr must contain pointers to the columns of A.
c            The nonzeros in column j of A must be in positions
c            acol_ptr(j), ... , acol_ptr(j+1) - 1.
c         On exit acol_ptr is unchanged.
c
c       arow_ind is an integer array of dimension nnz.
c         On entry arow_ind must contain row indices for the strict 
c            lower triangular part of A in compressed column storage.
c         On exit arow_ind is unchanged.
c
c       g is a double precision array of dimension n.
c         On entry g must contain the vector g.
c         On exit g is unchanged.
c
c       delta is a double precision variable.
c         On entry delta is the trust region size.
c         On exit delta is unchanged.
c
c       rtol is a double precision variable.
c         On entry rtol specifies the accuracy of the final minimizer.
c         On exit rtol is unchanged.
c
c       s is a double precision array of dimension n.
c         On entry s is the Cauchy step.
c         On exit s contain the final step.
c
c       nv is an integer variable.
c         On entry nv specifies the amount of memory available for the
c            incomplete Cholesky factorization. On exit the length of
c            the incomplete Cholesky factor is nnz + n*nv.
c         On exit nv is unchanged.
c
c       itermax is an integer variable.
c         On entry itermax specifies the limit on the number of
c            conjugate gradient iterations.
c         On exit itermax is unchanged.
c
c       iters is an integer variable.
c         On entry iters need not be specified.
c         On exit iters is set to the number of conjugate 
c            gradient iterations.
c
c       info is an integer variable.
c         On entry info need not be specified.
c         On exit info is set as follows:
c
c             info = 1  Convergence. The final step s satisfies
c                       || (g + A*s)[free] || <= rtol*|| g[free] ||,
c                       and the final x is an approximate minimizer
c                       in the face defined by the free variables.
c
c             info = 2  Termination. The trust region bound does 
c                       not allow further progress.
c
c             info = 3  Failure to converge within itermax iterations.
c
c       b is a double precision array of dimension nnz.
c         On entry b need not be specified.
c         On exit b contains the strict lower triangular part
c            of B in compressed column storage.
c
c       bdiag is a double precision array of dimension n.
c         On entry bdiag need not be specified.
c         On exit bdiag contains the diagonal elements of B.
c
c       bcol_ptr is an integer array of dimension n + 1.
c         On entry bcol_ptr need not be specified
c         On exit bcol_ptr contains pointers to the columns of B.
c            The nonzeros in column j of B are in the
c            bcol_ptr(j), ... , bcol_ptr(j+1) - 1 positions of b.
c
c       brow_ind is an integer array of dimension nnz.
c         On entry brow_ind need not be specified.
c         On exit brow_ind contains row indices for the strict lower
c            triangular part of B in compressed column storage. 
c
c       l is a double precision array of dimension nnz + n*nv.
c         On entry l need not be specified.
c         On exit l contains the strict lower triangular part
c            of L in compressed column storage.
c
c       ldiag is a double precision array of dimension n.
c         On entry ldiag need not be specified.
c         On exit ldiag contains the diagonal elements of L.
c
c       lcol_ptr is an integer array of dimension n + 1.
c         On entry lcol_ptr need not be specified.
c         On exit lcol_ptr contains pointers to the columns of L.
c            The nonzeros in column j of L are in the
c            lcol_ptr(j), ... , lcol_ptr(j+1) - 1 positions of l.
c
c       lrow_ind is an integer array of dimension nnz + n*nv.
c         On entry lrow_ind need not be specified.
c         On exit lrow_ind contains row indices for the strict lower
c            triangular part of L in compressed column storage. 
c
c       indfree is an integer working array of dimension n.
c
c       gfree is a double precision working array of dimension n.
c
c       w is a double precision working array of dimension n.
c
c       wa is a double precision work array of dimension 5*n.
c
c       iwa is an integer work array of dimension 3*n.
c
c     Subprograms called
c
c       MINPACK-2  ......  dmid, dprsrch, dtrpcg, 
c                          dstrsol
c
c       Level 1 BLAS  ...  daxpy, dnrm2
c
c     MINPACK-2 Project. March 1999.
c     Argonne National Laboratory.
c     Chih-Jen Lin and Jorge J. More'.
c
c     March 2000
c
c     Clarified documentation of nv variable.
c     Eliminated the nnz = max(nnz,1) statement.
c
c     **********
      double precision zero, one
      parameter(zero=0.0d0,one=1.0d0)

      integer infotr, j, itertr, nfaces, nfree
      double precision gfnorm, gfnormf
      double precision tol, stol

      double precision dnrm2
      external dmid, dprsrch, dtrpcg, dstrsol
      external daxpy, dnrm2

c     Compute A*(x[1] - x[0]) and store in w. 
   
      call aprod(n,s,w)

c     Compute the Cauchy point.

      call daxpy(n,one,s,1,x,1) 
      call dmid(n,x,xl,xu)

c     Start the main iteration loop.
c     There are at most n iterations because at each iteration
c     at least one variable becomes active.

      iters = 0  
      do nfaces = 1, n

c        Determine the free variables at the current minimizer.
c        The indices of the free variables are stored in the first
c        n free positions of the array indfree.
c        The array iwa is used to detect free variables by setting
c        iwa(i) = 1 if the ith variable is free, otherwise iwa(i) = 0.

         nfree  = 0
         do j = 1, n
            if (xl(j) .lt. x(j) .and. x(j) .lt. xu(j)) then
               nfree = nfree + 1 
               indfree(nfree) = j
               iwa(j) = nfree
            else
               iwa(j) = 0
            end if
         end do

c        Exit if there are no free constraints.

         if (nfree .eq. 0) then
            info = 1
            return
         end if

c        Obtain the submatrix of A for the free variables.
c        Recall that iwa allows the detection of free variables.
        
c$$$         bcol_ptr(1) = 1 
c$$$         nnz = 0
c$$$         do j = 1, nfree
c$$$            jfree = indfree(j)
c$$$            bdiag(j) = adiag(jfree)
c$$$            do ip = acol_ptr(jfree), acol_ptr(jfree+1)-1
c$$$               if (iwa(arow_ind(ip)) .gt. 0) then
c$$$                  nnz = nnz + 1
c$$$                  brow_ind(nnz) = iwa(arow_ind(ip))
c$$$                  b(nnz) = a(ip)
c$$$               end if
c$$$            end do
c$$$            bcol_ptr(j+1) = nnz + 1
c$$$         end do
        
c        Compute the incomplete Cholesky factorization.

c        alpha = zero
c        call dicfs(nfree,nnz,b,bdiag,bcol_ptr,brow_ind,
c    +              l,ldiag,lcol_ptr,lrow_ind,nv,alpha,
c    +              iwa,wa(1),wa(n+1)) 

c        Compute the gradient grad q(x[k]) = g + A*(x[k] - x[0]),
c        of q at x[k] for the free variables. 
c        Recall that w contains  A*(x[k] - x[0]).
c        Compute the norm of the reduced gradient Z'*g.

         do j = 1, nfree
            gfree(j) = w(indfree(j)) + g(indfree(j))
            wa(j) = g(indfree(j))
         end do
         gfnorm = dnrm2(nfree,wa,1)

c        Solve the trust region subproblem in the free variables
c        to generate a direction p[k]. Store p[k] in the array w.

         tol = rtol*gfnorm
         stol = zero

         call dtrpcg(n,nfree,indfree,aprod,gfree,
     +               delta,
     +               tol,stol,itermax,w,itertr,infotr,
     +               wx,wy,wa(1),wa(n+1),wa(2*n+1),wa(3*n+1),wa(4*n+1))

         iters = iters + itertr 
c        call dstrsol(nfree,l,ldiag,lcol_ptr,lrow_ind,w,'T')

c        Use a projected search to obtain the next iterate.
c        The projected search algorithm stores s[k] in w.

         do j = 1, nfree
            wa(j) = x(indfree(j))
            wa(n+j) = xl(indfree(j))
            wa(2*n+j) = xu(indfree(j))
         end do
        
         call dprsrch(n,nfree,indfree,aprod,wa(1),wa(n+1),wa(2*n+1),
     +                gfree,w,wx,wy,
     +                wa(3*n+1),wa(4*n+1))

c        Update the minimizer and the step.
c        Note that s now contains x[k+1] - x[0].
        
         do j = 1, nfree
            x(indfree(j)) = wa(j)
            s(indfree(j)) = s(indfree(j)) + w(j)
         end do

c        Compute A*(x[k+1] - x[0]) and store in w.

         call aprod(n,s,w)

c        Compute the gradient grad q(x[k+1]) = g + A*(x[k+1] - x[0])
c        of q at x[k+1] for the free variables.

         do j = 1, nfree
            gfree(j) = w(indfree(j)) + g(indfree(j))
         end do
         gfnormf = dnrm2(nfree,gfree,1)

c        Convergence and termination test. 
c        We terminate if the preconditioned conjugate gradient method 
c        encounters a direction of negative curvature, or
c        if the step is at the trust region bound.

         if (gfnormf .le. rtol*gfnorm) then
            info = 1
            return
         else if (infotr .eq. 3 .or. infotr .eq. 4) then
            info = 2
            return
         else if (iters .gt. itermax) then
            info = 3
            return         
         end if
        
      end do

      return

      end

      
